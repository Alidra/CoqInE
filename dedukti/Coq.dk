#NAME Coq

(; Sorts ;)

srt : Type.
p : srt.
z : srt.
t : srt -> srt.
[] t p --> t z.

r : srt -> srt -> srt.
[s : srt] r s p --> p
[s : srt] r p s --> s
[] r z z --> z
[s : srt] r (t s) z --> t s
[s : srt] r z (t s) --> t s
[s1 : srt, s2 : srt] r (t s1) (t s2) --> t (r s1 s2).

m : srt -> srt -> srt.
[s : srt] m s p --> s
[s : srt] m p s --> s
[] m z z --> z
[s : srt] m (t s) z --> t s
[s : srt] m z (t s) --> t s
[s1 : srt, s2 : srt] m (t s1) (t s2) --> t (m s1 s2).

cast_srt : srt -> srt -> srt.
[s : srt] cast_srt p s --> s
[s : srt] cast_srt z z --> z
[s : srt] cast_srt z (t s) --> (t s)
[s1 : srt, s2 : srt] cast_srt (t s1) (t s2) --> t (cast_srt s1 s2)
[s1 : srt, s2 : srt, s3 : srt] cast_srt (r s1 s2) (r s1 s3) --> r s1 (cast_srt s2 s3)
[s : srt] cast_srt s s --> s
[s1 : srt, s2 : srt, s3 : srt] cast_srt (cast_srt s1 s2) s3 --> cast_srt s1 s3.

(; Terms ;)

type : srt -> Type.
term : s : srt -> A : type s -> Type.
sort : s : srt -> type (t s).
prod : s1 : srt -> s2 : srt -> A : type s1 -> (term s1 A -> type s2) -> type (r s1 s2).
cast_type : s1 : srt -> s2 : srt -> type s1 -> type s2 -> type (cast_srt s1 s2).
cast : s1 : srt -> s2 : srt -> A : type s1 -> B : type s2 -> term s1 A -> term (cast_srt s1 s2) (cast_type s1 s2 A B).

[s : srt] term {t s} (sort s) --> type s
[s1 : srt, s2 : srt, A : type s1, B : term s1 A -> type s2] term {r s1 s2} (prod s1 s2 A B) --> x : term s1 A -> term s2 (B x).

[s1 : srt, s2 : srt] cast_type {t s1} {t s2} (sort s1) (sort s2) --> sort (cast_srt s1 s2)
[s1 : srt, s2 : srt, s3 : srt, A : type s1, B : term s1 A -> type s2, C : term s1 A -> type s3]
  cast_type {r s1 s2} {r s1 s3} (prod s1 s2 A B) (prod s1 s3 A C) -->
    prod s1 (cast_srt s2 s3) A (x : term s1 A => cast_type s2 s3 (B x) (C x))
[s : srt, A : type s] cast_type s s A A --> A
[s1 : srt, s2 : srt, s3 : srt, A : type s1, B : type s2, C : type s3]
  cast_type {cast_srt s1 s2} s3 (cast_type s1 s2 A B) C --> cast_type s1 s3 A C.

[s : srt, A : type s, x : term s A] cast s s A A x --> x
[s1 : srt, s2 : srt, s3 : srt, A : type s1, B : type s2, C : type s3, x : term s1 A]
  cast {cast_srt s1 s2} s3 {cast_type s1 s2 A B} C (cast s1 s2 A B x) --> cast s1 s3 A C x
[s1 : srt, s2 : srt, s3 : srt, A : type s1, B : term s1 A -> type s2, C : term s1 A -> type s3, f : x : term s1 A -> term s2 (B x)]
  cast {r s1 s2} {r s1 s3} (prod s1 s2 A B) (prod s1 s3 A C) f --> x : term s1 A => cast s2 s3 (B x) (C x) (f x).

(;[s1 : srt, s2 : srt] type (cast_srt s1 s2) --> type s1.;)
(;[s1 : srt, s2 : srt, s3 : srt] type (r (cast_srt s1 s3) s2) --> type (r s1 s2).;)
[s1 : srt, s2 : srt, A : type s1] term {cast_srt s1 s2} (cast {t s1} {t s2} (sort s1) (sort s2) A) --> term s1 A.
(;[s1 : srt, s2 : srt, s3 : srt, A : type s1, B : term s1 A -> type s2];)
(;  prod {cast_srt s1 s3} s2 (cast {t s1} {t s3} (sort s1) (sort s3) A) B --> prod s1 s2 A B.;)

(; Coinductives ;)

unit : Type.
tt : unit.

