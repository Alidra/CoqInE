(;-----------------------------------------------------------------;)
(;-----------------  FIXPOINTS DEFINITION SCHEME  -----------------;)
(;-----------------------------------------------------------------;)

(; Required rule ;)
[s] Rule s s s --> true.

(; Natural numbers ;)
N : Type.
_0 : N.
_S : N -> N.



(;-----------------  Arity  -----------------;)

(; SAc k s A   represents both
   - the arity of a single body in a mutually recursive block
     without the recursive call parameters.
   - the index of expected structurally decreasing inductive argument in arity ;)

SingleArity : Sort -> Type.
SAc : N -> s : Sort -> Univ s -> SingleArity s.

def make_SA := SAc.


(;-----------------  Fetch type from Arity  -----------------;)

def SA_arity : s : Sort -> SingleArity s -> Univ s.
[s,A] SA_arity s (SAc _ _ A) --> A.



(;-----------------  Arity Lists  -----------------;)

(; This is a sized list of single arities ;)

MutualArity : Sort -> N -> Type.
MAnil  : s : Sort -> MutualArity s _0.
MAcons : s : Sort -> n : N -> SingleArity s -> MutualArity s n -> MutualArity s (_S n).

(;-----------------  Short constructor: make_MA  -----------------;)

def MutualArity' : Sort -> N -> N -> Type.
[s,n  ] MutualArity' s n _0     --> MutualArity s n.
[s,n,i] MutualArity' s n (_S i) --> SingleArity s -> MutualArity' s n i.

def MAcons_aux :
  s : Sort ->
  n : N -> m : N ->
  SingleArity s ->
  MutualArity' s n m ->     (;  SA -> ...(m)... -> SA -> MAn    ;)
  MutualArity' s (_S n) m.  (;  SA -> ...(m)... -> SA -> MAn+1  ;)
[s,n  ,A,MA   ] MAcons_aux s n _0     A MA    --> MAcons s n A MA.
[s,n,m,A,MA,A'] MAcons_aux s n (_S m) A MA A' --> MAcons_aux s n m A (MA A').

(; Use directly    make_MA s 3 a b c     ;)
def make_MA : s : Sort -> n : N -> MutualArity' s n n.
[s     ] make_MA s _0        --> MAnil s.
[s,n,SA] make_MA s (_S n) SA --> MAcons_aux s n n SA (make_MA s n).

(;-----------------  Fetch Arity from Arity List  -----------------;)

def MA_ith_SA  : s : Sort -> n : N -> MutualArity s n -> N -> SingleArity s.
[s,SA]
  MA_ith_SA s _ (MAcons _ _ SA _) _0 --> SA.
[s,n,i,MA]
  MA_ith_SA s _ (MAcons _ n _ MA) (_S i)
  -->
  MA_ith_SA s n MA i.

(;-----------------  Fetch Type from Arity List  -----------------;)

def MA_ith_arity (s : Sort) (n : N) (MA : MutualArity s n) (i : N) : Univ s :=
  SA_arity s (MA_ith_SA s n MA i).





(;------  Fetch type with recursive call arguments from Arity List  -----;)

def MA_lift_arity :
  s : Sort -> Univ s -> m : N -> MutualArity s m -> Univ s.

[s,ar] MA_lift_arity s ar _ (MAnil _) --> ar.

[s,ar,m,SA,MA]
  MA_lift_arity s ar _ (MAcons _ m SA MA)
  -->
  prod s s s I (SA_arity s SA) (f => (MA_lift_arity s ar m MA)).

def MA_arity (s : Sort) (n : N) (MA : MutualArity s n) (i : N) : Univ s
  := MA_lift_arity s (MA_ith_arity s n MA i) n MA.



(;-----------------  Fixpoint Type  -----------------;)

(; Sized list of functions of each "type with recursive calls"  ;)

(; List of MA' arity lifted with MA ;)
MutualFixpointTypeAux :
  (s : Sort) ->
  (n : N) -> MutualArity s n ->
  (i : N) -> MutualArity s i -> Type.

def MutualFixpointType (s : Sort) (n : N) (MA : MutualArity s n) : Type
  :=
  MutualFixpointTypeAux s n MA n MA.

MFTnil :
  (s : Sort) ->
  (n : N) -> (MA : MutualArity s n) ->
  MutualFixpointTypeAux s n MA _0 (MAnil s).

MFTcons :
  (s : Sort) ->
  (n : N) -> (MAn : MutualArity s n) ->
  (i : N) -> (MAi : MutualArity s i) ->
  SA : SingleArity s ->
  Term s (MA_lift_arity s (SA_arity s SA) n MAn) ->
  MutualFixpointTypeAux s n MAn i MAi ->
  MutualFixpointTypeAux s n MAn (_S i) (MAcons s i SA MAi).

(;-----------------  Short constructor: fix  -----------------;)

def MutualFixpointType' :
  (s : Sort) ->
  (n : N) -> MutualArity s n ->
  (i : N) -> MutualArity s i ->
  (j : N) -> MutualArity s j ->
  Type.

[s,n,MAn,i,MAi]
  MutualFixpointType' s n MAn i MAi _ (MAnil _)
  -->
  MutualFixpointTypeAux s n MAn i MAi.

[s,n,MAn,i,MAi,SA,j,MAj]
  MutualFixpointType' s n MAn i MAi _ (MAcons _ j SA MAj)
  -->
  Term s (MA_lift_arity s (SA_arity s SA) n MAn) ->
  MutualFixpointType' s n MAn i MAi j MAj.


def fix' :
  (s : Sort) -> (n : N) -> (MAn : MutualArity s n) ->
  (i : N) -> (MAi : MutualArity s i) ->
  (j : N) -> (MAj : MutualArity s j) ->
  SA : SingleArity s ->
  Term s (MA_lift_arity s (SA_arity s SA) n MAn) ->
  MutualFixpointType' s n MAn i      MAi                 j MAj ->
  MutualFixpointType' s n MAn (_S i) (MAcons s i SA MAi) j MAj.

[s,n,MAn,i,MAi,SA,t,MFT]
  fix' s n MAn i MAi _ (MAnil _) SA t MFT
  -->
  MFTcons s n MAn i MAi SA t MFT.

[s,n,MAn,i,MAi,j,MAj,SA,t,MFT,t']
  fix' s n MAn i MAi (_S _) (MAcons _ j _ MAj) SA t MFT t'
  -->
  fix' s n MAn i MAi j MAj SA t (MFT t').


def make_fix :
  (s : Sort) -> (n : N) -> (MAn : MutualArity s n) ->
  (i : N) -> (MAi : MutualArity s i) ->
  MutualFixpointType' s n MAn i MAi i MAi.

[s,n,MAn]
  make_fix s n MAn _ (MAnil _)
  -->
  MFTnil s n MAn.

[s,n,MAn,j,MAj,SA,t]
  make_fix s n MAn (_S _) (MAcons _ j SA MAj) t
  -->
  fix' s n MAn j MAj j MAj SA t (make_fix s n MAn j MAj).

def fix :
  s : Sort ->
  n : N ->
  MA: MutualArity s n -> MutualFixpointType' s n MA n MA n MA.

[s,n,MAn] fix s n MAn --> make_fix s n MAn n MAn.



def fix_body :
  s : Sort ->
  n : N ->
  MA: MutualArity s n ->
  MutualFixpointType s n MA ->
  i : N ->
  Term s (MA_arity s n MA i).

def fix_body' :
  s : Sort ->
  n : N -> MAn : MutualArity s n ->
  i : N -> MAi : MutualArity s i ->
  MutualFixpointTypeAux s n MAn i MAi ->
  j : N ->
  Term s (MA_lift_arity s (SA_arity s (MA_ith_SA s i MAi j)) n MAn).
[s,n,MA,MF,i] fix_body s n MA MF i --> fix_body' s n MA n MA MF i.

[s,n,MA,SA,t]
  fix_body' s n MA (_S _) (MAcons _ _ SA _) (MFTcons _ _ _ _ _ _ t _) _0
  -->
  t.

[s,n,MA,i,MAi,MFT,j]
  fix_body' s n MA (_S _) (MAcons _ i _ MAi) (MFTcons _ _ _ _ _ _ _ MFT) (_S j)
  -->
  fix_body' s n MA i MAi MFT j.



def lift (s : Sort) (s' : Sort) := cast' s s' (univ' s s) (univ' s' s').

def app_body :
  s : Sort ->
  n : N -> MA : MutualArity s n ->
  s1 : Sort ->
  s2 : Sort ->
  A : Univ s1 ->
  B : (Term s1 A -> Univ s2) ->
  body : Term s (MA_lift_arity s (prod' s1 s2 s A (x => B x)) n MA) ->
  a : Term s1 A ->
  Term s (MA_lift_arity s (lift s2 s (B a)) n MA).

def fix_proj :
  s : Sort ->
  n : N -> MA: MutualArity s n ->
  MutualFixpointType s n MA ->
  i : N ->
  Term s (MA_ith_arity s n MA i).

def fix_proj_1 :
  s : Sort ->
  n : N -> MA : MutualArity s n ->
  MutualFixpointType s n MA ->
  SA : SingleArity s ->
  Term s (MA_lift_arity s (SA_arity s SA) n MA) ->
  Term s (SA_arity s SA).

[s,n,MA,MF,i]
  fix_proj s n MA MF i
  -->
  fix_proj_1 s n MA MF (MA_ith_SA s n MA i) (fix_body s n MA MF i).

[s,n,MA,MF,i,A,B,body,a,s1,s2]
  fix_proj_1 s n MA MF (SAc (_S i) _ (prod' s1 s2 _ A (x => B x))) body a
  -->
  fix_proj_1 s n MA MF
    (SAc i s (lift s2 s (B a)))
    (app_body s n MA s1 s2 A (x => B x) body a).

Guarded? : Type.
guarded : Guarded?.
def guarded? : s : Sort -> Ind : Univ s -> Term s Ind -> Guarded?.

def fix_proj_2 :
  s : Sort ->
  n : N -> MA : MutualArity s n ->
  MutualFixpointType s n MA ->
  A : Univ s ->
  Term s (MA_lift_arity s A n MA) ->
  Guarded? ->
  Term s A.

[s,n,MA,MF,Ind,B,body,a,s1]
  fix_proj_1 s n MA MF (SAc _0 _ (prod' s1 s _ Ind (x => B x))) body a
  -->
  fix_proj_2 s n MA MF
    (prod' s1 s s Ind (x => B x))
    body (guarded? s1 Ind a) a.

def fix_proj_3 :
  s : Sort ->
  n : N -> MA : MutualArity s n ->
  MutualFixpointType s n MA ->
  i : N -> MAi : MutualArity s i ->
  A : Univ s ->
  Term s (MA_lift_arity s A i MAi) ->
  Term s A.

[s,n,MA,MF,A,body]
  fix_proj_2 s n MA MF A body guarded
  -->
  fix_proj_3 s n MA MF n MA A body.

[body] fix_proj_3 _ _ _ _ _ (MAnil _) _ body --> body.

[s,n,MA,MF,A,body]
  fix_proj_3 s n MA MF _ (MAcons _ _ _ MAi) A body  <---  g1 -> ... -> gn -> A
  -->
  fix_proj_3 s n MA MF _ (MAcons _ _ _ MAi) A body g1) (fix_proj ... 2) (fix_proj ... 3)


  body (fix_proj ... 1) (fix_proj ... 2) (fix_proj ... 3)

  fix_proj_3 s n MA MF n MA A (body (fix_proj )  )
  .



(;
Fixpoint a := a
with     b := b
with     c := c.
;)

def 1 := _S _0.
def 2 := _S 1.
def 3 := _S 2.
A : Univ set.
B : Univ set.
C : Univ set.

def SA_A : SingleArity set   := make_SA _0 set A.
def SA_B : SingleArity set   := make_SA _0 set B.
def SA_C : SingleArity set   := make_SA _0 set C.
def MA   : MutualArity set 3 := make_MA set 3 SA_A SA_B SA_C.
def MFT  : MutualFixpointType set 3 MA :=
  fix set 3 MA (a => b => c => a) (a => b => c => b) (a => b => c => c).

def body_a := fix_body set 3 MA MFT _0.
def body_b := fix_body set 3 MA MFT 1.
def body_c := fix_body set 3 MA MFT 2.

def a    : Term set A := fix_proj set 3 MA MFT _0.
def b    : Term set B := fix_proj set 3 MA MFT 1.
def c    : Term set C := fix_proj set 3 MA MFT 2.

[] guarded? set A a --> guarded.
[] guarded? set B b --> guarded.
[] guarded? set C c --> guarded.







(; We ambitiously translate the following inductive definition:

Inductive nat : Type :=
| Z : nat
| S : nat -> nat.

Fixpoint plus (x:nat) (y:nat) :=
  match x with
  | Z => y
  | S x' => S (plus x' y)
  end.

Fixpoint times (x:nat) (y:nat) :=
  match x with
  | Z => Z
  | S x' => plus y (times x' y)
  end.

Inductive vect : nat -> Type :=
| nil : vect Z
| cons : forall n : nat, nat -> vect n -> vect (S n).

Fixpoint f acc n (v:vect n) {struct v} :=
  match v with
  | nil => acc
  | cons n' e v' => g (plus acc e) n' v'
  end
with g acc n v {struct v} :=
  match v with
  | nil => acc
  | cons n' e v' => f (times acc e) n' v'
  end
.

;)



(; This file was automatically generated by Coqine. ;)
(; The encoding used was: "universo". ;)

nat :
  Coq.Univ Coq.set.

def Z :
  Coq.Term Coq.set nat.

def S :
  __ : Coq.Term Coq.set nat -> Coq.Term Coq.set nat.

def match____nat :
  s : Coq.Sort ->
  P : (Coq.Term Coq.set nat -> Coq.Univ s) ->
  case__Z : Coq.Term s (P Z) ->
  case__S : (__ : Coq.Term Coq.set nat -> Coq.Term s (P (S __))) ->
  x : Coq.Term Coq.set nat ->
  Coq.Term s (P x).

[ s, P, case__Z, case__S]

  match____nat s P case__Z case__S Z -->

  case__Z.

[ s, P, case__Z, case__S, __]

  match____nat s P case__Z case__S (S __) -->

  case__S __.

[ s, P, s']

  match____nat s (x => Coq.cast' _ _ (Coq.univ' s' _) _ (P x)) -->

  match____nat s' (x => P x).


P : n : Coq.Term Coq.set nat -> Coq.Univ (Coq.type Coq.z).
f0 : Coq.Term (Coq.type Coq.z) (P Z).
f1 : n : Coq.Term Coq.set nat ->
     __ : Coq.Term (Coq.type Coq.z) (P n) ->
     Coq.Term (Coq.type Coq.z) (P (S n)).

(;     f_0  /  0  :  forall n:nat, P n     ;)
def nat__rect__SA : SingleArity (type z) :=
  make_SA _0 (type z) (prod set (type z) (type z) I nat (n => P n)).

(;   { f_0  /  0  :  forall n:nat, P n }   ;)
def nat__rect__MA : MutualArity (type z) (_S _0) :=
  make_MA (type z) (_S _0) nat__rect__SA.

#EVAL[SNF] Term (type z) (SA_arity (type z) nat__rect__SA).
#EVAL[SNF] Term (type z) (MA_ith_arity (type z) (_S _0) nat__rect__MA _0).

#EVAL[SNF] Term (type z) (MA_arity (type z) (_S _0) nat__rect__MA _0).

def nat__rect__FP : MutualFixpointType (type z) (_S _0) nat__rect__MA :=
  fix (type z) (_S _0) nat__rect__MA
    (nat__rect => n =>
      match____nat (Coq.type Coq.z) (n0 : Coq.Term Coq.set nat => P n0)
        f0
        (n0 : Coq.Term Coq.set nat => f1 n0 (nat__rect n0))
        n).

def nat__rect := fix_proj (type z) (_S _0) nat__rect__MA nat__rect__FP _0.

#CHECK nat__rect  :  ( n : Term set nat -> Term (type z) (P n) ).



(;

def nat__rect :

  P : (n : Coq.Term Coq.set nat -> Coq.Univ (Coq.type Coq.z)) ->
  f0 : Coq.Term (Coq.type Coq.z) (P Z) ->
  f1 :
    (n : Coq.Term Coq.set nat ->
     __ : Coq.Term (Coq.type Coq.z) (P n) ->
     Coq.Term (Coq.type Coq.z) (P (S n))) ->
  n : Coq.Term Coq.set nat ->
  Coq.Term (Coq.type Coq.z) (P n) :=

  P : (n : Coq.Term Coq.set nat -> Coq.Univ (Coq.type Coq.z)) =>
  f0 : Coq.Term (Coq.type Coq.z) (P Z) =>
  f1 :
    (n : Coq.Term Coq.set nat ->
     __ : Coq.Term (Coq.type Coq.z) (P n) ->
     Coq.Term (Coq.type Coq.z) (P (S n))) =>
  match____nat (Coq.type Coq.z) (n0 : Coq.Term Coq.set nat => P n0) f0
    (n0 : Coq.Term Coq.set nat => f1 n0 (nat__rect P f0 f1 n0)) n.






def fix1__F :
  P : (n : Coq.Term Coq.set nat -> Coq.Univ (Coq.type Coq.z)) ->
  f0 : Coq.Term (Coq.type Coq.z) (P Z) ->
  f1 :
    (n : Coq.Term Coq.set nat ->
     __ : Coq.Term (Coq.type Coq.z) (P n) ->
     Coq.Term (Coq.type Coq.z) (P (S n))) ->
  n : Coq.Term Coq.set nat ->
  Coq.Term (Coq.type Coq.z) (P n).

def fix2__F :
  P : (n : Coq.Term Coq.set nat -> Coq.Univ (Coq.type Coq.z)) ->
  f0 : Coq.Term (Coq.type Coq.z) (P Z) ->
  f1 :
    (n : Coq.Term Coq.set nat ->
     __ : Coq.Term (Coq.type Coq.z) (P n) ->
     Coq.Term (Coq.type Coq.z) (P (S n))) ->
  n : Coq.Term Coq.set nat ->
  __ : Coq.Term Coq.set nat ->
  Coq.Term (Coq.type Coq.z) (P n).

def fix3__F :
  P : (n : Coq.Term Coq.set nat -> Coq.Univ (Coq.type Coq.z)) ->
  f0 : Coq.Term (Coq.type Coq.z) (P Z) ->
  f1 :
    (n : Coq.Term Coq.set nat ->
     __ : Coq.Term (Coq.type Coq.z) (P n) ->
     Coq.Term (Coq.type Coq.z) (P (S n))) ->
  n : Coq.Term Coq.set nat ->
  Coq.Term (Coq.type Coq.z) (P n).

[ P, f0, f1, n]

  fix1__F P f0 f1 n -->

  fix2__F P f0 f1 n n.

[ P, f0, f1, n]

  fix2__F P f0 f1 n Z -->

  fix3__F P f0 f1 n.

[ P, f0, f1, n]

  fix2__F P f0 f1 n (S _) -->

  fix3__F P f0 f1 n.

[ P, f0, f1]

  fix3__F P f0 f1 -->

  n : Coq.Term Coq.set nat =>
  match____nat (Coq.type Coq.z) (n0 : Coq.Term Coq.set nat => P n0) f0
    (n0 : Coq.Term Coq.set nat => f1 n0 (fix1__F P f0 f1 n0)) n.

def nat__rect :

  P : (n : Coq.Term Coq.set nat -> Coq.Univ (Coq.type Coq.z)) ->
  f0 : Coq.Term (Coq.type Coq.z) (P Z) ->
  f1 :
    (n : Coq.Term Coq.set nat ->
     __ : Coq.Term (Coq.type Coq.z) (P n) ->
     Coq.Term (Coq.type Coq.z) (P (S n))) ->
  n : Coq.Term Coq.set nat ->
  Coq.Term (Coq.type Coq.z) (P n) :=

  P : (n : Coq.Term Coq.set nat -> Coq.Univ (Coq.type Coq.z)) =>
  f0 : Coq.Term (Coq.type Coq.z) (P Z) =>
  f1 :
    (n : Coq.Term Coq.set nat ->
     __ : Coq.Term (Coq.type Coq.z) (P n) ->
     Coq.Term (Coq.type Coq.z) (P (S n))) =>
  fix1__F P f0 f1.

def fix1__F0 :
  P : (n : Coq.Term Coq.set nat -> Coq.Univ Coq.prop) ->
  f0 : Coq.Term Coq.prop (P Z) ->
  f1 :
    (n : Coq.Term Coq.set nat ->
     __ : Coq.Term Coq.prop (P n) ->
     Coq.Term Coq.prop (P (S n))) ->
  n : Coq.Term Coq.set nat ->
  Coq.Term Coq.prop (P n).

def fix2__F0 :
  P : (n : Coq.Term Coq.set nat -> Coq.Univ Coq.prop) ->
  f0 : Coq.Term Coq.prop (P Z) ->
  f1 :
    (n : Coq.Term Coq.set nat ->
     __ : Coq.Term Coq.prop (P n) ->
     Coq.Term Coq.prop (P (S n))) ->
  n : Coq.Term Coq.set nat ->
  __ : Coq.Term Coq.set nat ->
  Coq.Term Coq.prop (P n).

def fix3__F0 :
  P : (n : Coq.Term Coq.set nat -> Coq.Univ Coq.prop) ->
  f0 : Coq.Term Coq.prop (P Z) ->
  f1 :
    (n : Coq.Term Coq.set nat ->
     __ : Coq.Term Coq.prop (P n) ->
     Coq.Term Coq.prop (P (S n))) ->
  n : Coq.Term Coq.set nat ->
  Coq.Term Coq.prop (P n).

[ P, f0, f1, n]

  fix1__F0 P f0 f1 n -->

  fix2__F0 P f0 f1 n n.

[ P, f0, f1, n]

  fix2__F0 P f0 f1 n Z -->

  fix3__F0 P f0 f1 n.

[ P, f0, f1, n]

  fix2__F0 P f0 f1 n (S _) -->

  fix3__F0 P f0 f1 n.

[ P, f0, f1]

  fix3__F0 P f0 f1 -->

  n : Coq.Term Coq.set nat =>
  match____nat Coq.prop (n0 : Coq.Term Coq.set nat => P n0) f0
    (n0 : Coq.Term Coq.set nat => f1 n0 (fix1__F0 P f0 f1 n0)) n.

def nat__ind :

  P : (n : Coq.Term Coq.set nat -> Coq.Univ Coq.prop) ->
  f0 : Coq.Term Coq.prop (P Z) ->
  f1 :
    (n : Coq.Term Coq.set nat ->
     __ : Coq.Term Coq.prop (P n) ->
     Coq.Term Coq.prop (P (S n))) ->
  n : Coq.Term Coq.set nat ->
  Coq.Term Coq.prop (P n) :=

  P : (n : Coq.Term Coq.set nat -> Coq.Univ Coq.prop) =>
  f0 : Coq.Term Coq.prop (P Z) =>
  f1 :
    (n : Coq.Term Coq.set nat ->
     __ : Coq.Term Coq.prop (P n) ->
     Coq.Term Coq.prop (P (S n))) =>
  fix1__F0 P f0 f1.

def nat__rec :

  P : (n : Coq.Term Coq.set nat -> Coq.Univ Coq.set) ->
  f0 : Coq.Term Coq.set (P Z) ->
  f1 :
    (n : Coq.Term Coq.set nat ->
     __ : Coq.Term Coq.set (P n) ->
     Coq.Term Coq.set (P (S n))) ->
  n : Coq.Term Coq.set nat ->
  Coq.Term Coq.set (P n) :=

  P : (n : Coq.Term Coq.set nat -> Coq.Univ Coq.set) =>
  nat__rect
    (Coq.cast (Coq.rule Coq.set (Coq.type Coq.z))
       (Coq.rule Coq.set (Coq.type (Coq.s Coq.z)))
       (Coq.prod Coq.set (Coq.type Coq.z) (Coq.rule Coq.set (Coq.type Coq.z))
          Coq.I nat
          (n : Coq.Term Coq.set nat =>
           Coq.univ Coq.set (Coq.type Coq.z) Coq.I))
       (Coq.prod Coq.set (Coq.type (Coq.s Coq.z))
          (Coq.rule Coq.set (Coq.type (Coq.s Coq.z))) Coq.I nat
          (n : Coq.Term Coq.set nat =>
           Coq.univ (Coq.type Coq.z) (Coq.type (Coq.s Coq.z)) Coq.I))
       Coq.I P).

def fix1__plus :
  x : Coq.Term Coq.set nat ->
  y : Coq.Term Coq.set nat ->
  Coq.Term Coq.set nat.

def fix2__plus :
  x : Coq.Term Coq.set nat ->
  __ : Coq.Term Coq.set nat ->
  y : Coq.Term Coq.set nat ->
  Coq.Term Coq.set nat.

def fix3__plus :
  x : Coq.Term Coq.set nat ->
  y : Coq.Term Coq.set nat ->
  Coq.Term Coq.set nat.

[ x]

  fix1__plus x -->

  fix2__plus x x.

[ x]

  fix2__plus x Z -->

  fix3__plus x.

[ x]

  fix2__plus x (S _) -->

  fix3__plus x.

[ ]

  fix3__plus -->

  x : Coq.Term Coq.set nat =>
  y : Coq.Term Coq.set nat =>
  match____nat Coq.set (x0 : Coq.Term Coq.set nat => nat) y
    (x_27_ : Coq.Term Coq.set nat => S (fix1__plus x_27_ y)) x.

def plus :

  x : Coq.Term Coq.set nat ->
  y : Coq.Term Coq.set nat ->
  Coq.Term Coq.set nat :=

  fix1__plus.

def fix1__times :
  x : Coq.Term Coq.set nat ->
  y : Coq.Term Coq.set nat ->
  Coq.Term Coq.set nat.

def fix2__times :
  x : Coq.Term Coq.set nat ->
  __ : Coq.Term Coq.set nat ->
  y : Coq.Term Coq.set nat ->
  Coq.Term Coq.set nat.

def fix3__times :
  x : Coq.Term Coq.set nat ->
  y : Coq.Term Coq.set nat ->
  Coq.Term Coq.set nat.

[ x]

  fix1__times x -->

  fix2__times x x.

[ x]

  fix2__times x Z -->

  fix3__times x.

[ x]

  fix2__times x (S _) -->

  fix3__times x.

[ ]

  fix3__times -->

  x : Coq.Term Coq.set nat =>
  y : Coq.Term Coq.set nat =>
  match____nat Coq.set (x0 : Coq.Term Coq.set nat => nat) Z
    (x_27_ : Coq.Term Coq.set nat => plus y (fix1__times x_27_ y)) x.

def times :

  x : Coq.Term Coq.set nat ->
  y : Coq.Term Coq.set nat ->
  Coq.Term Coq.set nat :=

  fix1__times.

vect :
  __ : Coq.Term Coq.set nat -> Coq.Univ Coq.set.

def nil :
  Coq.Term Coq.set (vect Z).

def cons :
  n : Coq.Term Coq.set nat ->
  __ : Coq.Term Coq.set nat ->
  __0 : Coq.Term Coq.set (vect n) ->
  Coq.Term Coq.set (vect (S n)).

def match____vect :
  s : Coq.Sort ->
  P : (__ : Coq.Term Coq.set nat -> Coq.Term Coq.set (vect __) -> Coq.Univ s) ->
  case__nil : Coq.Term s (P Z nil) ->
  case__cons :
    (n : Coq.Term Coq.set nat ->
     __ : Coq.Term Coq.set nat ->
     __0 : Coq.Term Coq.set (vect n) ->
     Coq.Term s (P (S n) (cons n __ __0))) ->
  __ : Coq.Term Coq.set nat ->
  x : Coq.Term Coq.set (vect __) ->
  Coq.Term s (P __ x).

[ s, P, case__nil, case__cons]

  match____vect s P case__nil case__cons {Z} nil -->

  case__nil.

[ s, P, case__nil, case__cons, n, __, __0]

  match____vect s P case__nil case__cons {S n} (cons n __ __0) -->

  case__cons n __ __0.

[ s, P, s']

  match____vect s (__ => x => Coq.cast' _ _ (Coq.univ' s' _) _ (P __ x)) -->

  match____vect s' (__ => x => P __ x).

def fix1__F1 :
  P :
    (n : Coq.Term Coq.set nat ->
     v : Coq.Term Coq.set (vect n) ->
     Coq.Univ (Coq.type Coq.z)) ->
  f0 : Coq.Term (Coq.type Coq.z) (P Z nil) ->
  f1 :
    (n : Coq.Term Coq.set nat ->
     n0 : Coq.Term Coq.set nat ->
     v : Coq.Term Coq.set (vect n) ->
     __ : Coq.Term (Coq.type Coq.z) (P n v) ->
     Coq.Term (Coq.type Coq.z) (P (S n) (cons n n0 v))) ->
  n : Coq.Term Coq.set nat ->
  v : Coq.Term Coq.set (vect n) ->
  Coq.Term (Coq.type Coq.z) (P n v).

def fix2__F1 :
  P :
    (n : Coq.Term Coq.set nat ->
     v : Coq.Term Coq.set (vect n) ->
     Coq.Univ (Coq.type Coq.z)) ->
  f0 : Coq.Term (Coq.type Coq.z) (P Z nil) ->
  f1 :
    (n : Coq.Term Coq.set nat ->
     n0 : Coq.Term Coq.set nat ->
     v : Coq.Term Coq.set (vect n) ->
     __ : Coq.Term (Coq.type Coq.z) (P n v) ->
     Coq.Term (Coq.type Coq.z) (P (S n) (cons n n0 v))) ->
  n : Coq.Term Coq.set nat ->
  v : Coq.Term Coq.set (vect n) ->
  __ : Coq.Term Coq.set nat ->
  __0 : Coq.Term Coq.set (vect __) ->
  Coq.Term (Coq.type Coq.z) (P n v).

def fix3__F1 :
  P :
    (n : Coq.Term Coq.set nat ->
     v : Coq.Term Coq.set (vect n) ->
     Coq.Univ (Coq.type Coq.z)) ->
  f0 : Coq.Term (Coq.type Coq.z) (P Z nil) ->
  f1 :
    (n : Coq.Term Coq.set nat ->
     n0 : Coq.Term Coq.set nat ->
     v : Coq.Term Coq.set (vect n) ->
     __ : Coq.Term (Coq.type Coq.z) (P n v) ->
     Coq.Term (Coq.type Coq.z) (P (S n) (cons n n0 v))) ->
  n : Coq.Term Coq.set nat ->
  v : Coq.Term Coq.set (vect n) ->
  Coq.Term (Coq.type Coq.z) (P n v).

[ P, f0, f1, n, v]

  fix1__F1 P f0 f1 n v -->

  fix2__F1 P f0 f1 n v n v.

[ P, f0, f1, n, v]

  fix2__F1 P f0 f1 n v _ nil -->

  fix3__F1 P f0 f1 n v.

[ P, f0, f1, n, v]

  fix2__F1 P f0 f1 n v _ (cons _ _ _) -->

  fix3__F1 P f0 f1 n v.

[ P, f0, f1]

  fix3__F1 P f0 f1 -->

  n : Coq.Term Coq.set nat =>
  v : Coq.Term Coq.set (vect n) =>
  match____vect (Coq.type Coq.z)
    (n0 : Coq.Term Coq.set nat => v0 : Coq.Term Coq.set (vect n0) => P n0 v0)
    f0
    (n0 : Coq.Term Coq.set nat =>
     n1 : Coq.Term Coq.set nat =>
     v0 : Coq.Term Coq.set (vect n0) =>
     f1 n0 n1 v0 (fix1__F1 P f0 f1 n0 v0))
    n v.

def vect__rect :

  P :
    (n : Coq.Term Coq.set nat ->
     v : Coq.Term Coq.set (vect n) ->
     Coq.Univ (Coq.type Coq.z)) ->
  f0 : Coq.Term (Coq.type Coq.z) (P Z nil) ->
  f1 :
    (n : Coq.Term Coq.set nat ->
     n0 : Coq.Term Coq.set nat ->
     v : Coq.Term Coq.set (vect n) ->
     __ : Coq.Term (Coq.type Coq.z) (P n v) ->
     Coq.Term (Coq.type Coq.z) (P (S n) (cons n n0 v))) ->
  n : Coq.Term Coq.set nat ->
  v : Coq.Term Coq.set (vect n) ->
  Coq.Term (Coq.type Coq.z) (P n v) :=

  P :
    (n : Coq.Term Coq.set nat ->
     v : Coq.Term Coq.set (vect n) ->
     Coq.Univ (Coq.type Coq.z)) =>
  f0 : Coq.Term (Coq.type Coq.z) (P Z nil) =>
  f1 :
    (n : Coq.Term Coq.set nat ->
     n0 : Coq.Term Coq.set nat ->
     v : Coq.Term Coq.set (vect n) ->
     __ : Coq.Term (Coq.type Coq.z) (P n v) ->
     Coq.Term (Coq.type Coq.z) (P (S n) (cons n n0 v))) =>
  fix1__F1 P f0 f1.

def fix1__F2 :
  P :
    (n : Coq.Term Coq.set nat ->
     v : Coq.Term Coq.set (vect n) ->
     Coq.Univ Coq.prop) ->
  f0 : Coq.Term Coq.prop (P Z nil) ->
  f1 :
    (n : Coq.Term Coq.set nat ->
     n0 : Coq.Term Coq.set nat ->
     v : Coq.Term Coq.set (vect n) ->
     __ : Coq.Term Coq.prop (P n v) ->
     Coq.Term Coq.prop (P (S n) (cons n n0 v))) ->
  n : Coq.Term Coq.set nat ->
  v : Coq.Term Coq.set (vect n) ->
  Coq.Term Coq.prop (P n v).

def fix2__F2 :
  P :
    (n : Coq.Term Coq.set nat ->
     v : Coq.Term Coq.set (vect n) ->
     Coq.Univ Coq.prop) ->
  f0 : Coq.Term Coq.prop (P Z nil) ->
  f1 :
    (n : Coq.Term Coq.set nat ->
     n0 : Coq.Term Coq.set nat ->
     v : Coq.Term Coq.set (vect n) ->
     __ : Coq.Term Coq.prop (P n v) ->
     Coq.Term Coq.prop (P (S n) (cons n n0 v))) ->
  n : Coq.Term Coq.set nat ->
  v : Coq.Term Coq.set (vect n) ->
  __ : Coq.Term Coq.set nat ->
  __0 : Coq.Term Coq.set (vect __) ->
  Coq.Term Coq.prop (P n v).

def fix3__F2 :
  P :
    (n : Coq.Term Coq.set nat ->
     v : Coq.Term Coq.set (vect n) ->
     Coq.Univ Coq.prop) ->
  f0 : Coq.Term Coq.prop (P Z nil) ->
  f1 :
    (n : Coq.Term Coq.set nat ->
     n0 : Coq.Term Coq.set nat ->
     v : Coq.Term Coq.set (vect n) ->
     __ : Coq.Term Coq.prop (P n v) ->
     Coq.Term Coq.prop (P (S n) (cons n n0 v))) ->
  n : Coq.Term Coq.set nat ->
  v : Coq.Term Coq.set (vect n) ->
  Coq.Term Coq.prop (P n v).

[ P, f0, f1, n, v]

  fix1__F2 P f0 f1 n v -->

  fix2__F2 P f0 f1 n v n v.

[ P, f0, f1, n, v]

  fix2__F2 P f0 f1 n v _ nil -->

  fix3__F2 P f0 f1 n v.

[ P, f0, f1, n, v]

  fix2__F2 P f0 f1 n v _ (cons _ _ _) -->

  fix3__F2 P f0 f1 n v.

[ P, f0, f1]

  fix3__F2 P f0 f1 -->

  n : Coq.Term Coq.set nat =>
  v : Coq.Term Coq.set (vect n) =>
  match____vect Coq.prop
    (n0 : Coq.Term Coq.set nat => v0 : Coq.Term Coq.set (vect n0) => P n0 v0)
    f0
    (n0 : Coq.Term Coq.set nat =>
     n1 : Coq.Term Coq.set nat =>
     v0 : Coq.Term Coq.set (vect n0) =>
     f1 n0 n1 v0 (fix1__F2 P f0 f1 n0 v0))
    n v.

def vect__ind :

  P :
    (n : Coq.Term Coq.set nat ->
     v : Coq.Term Coq.set (vect n) ->
     Coq.Univ Coq.prop) ->
  f0 : Coq.Term Coq.prop (P Z nil) ->
  f1 :
    (n : Coq.Term Coq.set nat ->
     n0 : Coq.Term Coq.set nat ->
     v : Coq.Term Coq.set (vect n) ->
     __ : Coq.Term Coq.prop (P n v) ->
     Coq.Term Coq.prop (P (S n) (cons n n0 v))) ->
  n : Coq.Term Coq.set nat ->
  v : Coq.Term Coq.set (vect n) ->
  Coq.Term Coq.prop (P n v) :=

  P :
    (n : Coq.Term Coq.set nat ->
     v : Coq.Term Coq.set (vect n) ->
     Coq.Univ Coq.prop) =>
  f0 : Coq.Term Coq.prop (P Z nil) =>
  f1 :
    (n : Coq.Term Coq.set nat ->
     n0 : Coq.Term Coq.set nat ->
     v : Coq.Term Coq.set (vect n) ->
     __ : Coq.Term Coq.prop (P n v) ->
     Coq.Term Coq.prop (P (S n) (cons n n0 v))) =>
  fix1__F2 P f0 f1.

def vect__rec :

  P :
    (n : Coq.Term Coq.set nat ->
     v : Coq.Term Coq.set (vect n) ->
     Coq.Univ Coq.set) ->
  f0 : Coq.Term Coq.set (P Z nil) ->
  f1 :
    (n : Coq.Term Coq.set nat ->
     n0 : Coq.Term Coq.set nat ->
     v : Coq.Term Coq.set (vect n) ->
     __ : Coq.Term Coq.set (P n v) ->
     Coq.Term Coq.set (P (S n) (cons n n0 v))) ->
  n : Coq.Term Coq.set nat ->
  v : Coq.Term Coq.set (vect n) ->
  Coq.Term Coq.set (P n v) :=

  P :
    (n : Coq.Term Coq.set nat ->
     v : Coq.Term Coq.set (vect n) ->
     Coq.Univ Coq.set) =>
  vect__rect
    (Coq.cast (Coq.rule Coq.set (Coq.rule Coq.set (Coq.type Coq.z)))
       (Coq.rule Coq.set (Coq.rule Coq.set (Coq.type (Coq.s Coq.z))))
       (Coq.prod Coq.set (Coq.rule Coq.set (Coq.type Coq.z))
          (Coq.rule Coq.set (Coq.rule Coq.set (Coq.type Coq.z))) Coq.I nat
          (n : Coq.Term Coq.set nat =>
           Coq.prod Coq.set (Coq.type Coq.z)
             (Coq.rule Coq.set (Coq.type Coq.z)) Coq.I (vect n)
             (v : Coq.Term Coq.set (vect n) =>
              Coq.univ Coq.set (Coq.type Coq.z) Coq.I)))
       (Coq.prod Coq.set (Coq.rule Coq.set (Coq.type (Coq.s Coq.z)))
          (Coq.rule Coq.set (Coq.rule Coq.set (Coq.type (Coq.s Coq.z))))
          Coq.I nat
          (n : Coq.Term Coq.set nat =>
           Coq.prod Coq.set (Coq.type (Coq.s Coq.z))
             (Coq.rule Coq.set (Coq.type (Coq.s Coq.z))) Coq.I (vect n)
             (v : Coq.Term Coq.set (vect n) =>
              Coq.univ (Coq.type Coq.z) (Coq.type (Coq.s Coq.z)) Coq.I)))
       Coq.I P).

def fix1__f :
  acc : Coq.Term Coq.set nat ->
  n : Coq.Term Coq.set nat ->
  v : Coq.Term Coq.set (vect n) ->
  Coq.Term Coq.set nat.

def fix2__f :
  acc : Coq.Term Coq.set nat ->
  n : Coq.Term Coq.set nat ->
  v : Coq.Term Coq.set (vect n) ->
  __ : Coq.Term Coq.set nat ->
  __0 : Coq.Term Coq.set (vect __) ->
  Coq.Term Coq.set nat.

def fix3__f :
  acc : Coq.Term Coq.set nat ->
  n : Coq.Term Coq.set nat ->
  v : Coq.Term Coq.set (vect n) ->
  Coq.Term Coq.set nat.

def fix1__g :
  acc : Coq.Term Coq.set nat ->
  n : Coq.Term Coq.set nat ->
  v : Coq.Term Coq.set (vect n) ->
  Coq.Term Coq.set nat.

def fix2__g :
  acc : Coq.Term Coq.set nat ->
  n : Coq.Term Coq.set nat ->
  v : Coq.Term Coq.set (vect n) ->
  __ : Coq.Term Coq.set nat ->
  __0 : Coq.Term Coq.set (vect __) ->
  Coq.Term Coq.set nat.

def fix3__g :
  acc : Coq.Term Coq.set nat ->
  n : Coq.Term Coq.set nat ->
  v : Coq.Term Coq.set (vect n) ->
  Coq.Term Coq.set nat.

[ acc, n, v]

  fix1__f acc n v -->

  fix2__f acc n v n v.

[ acc, n, v]

  fix2__f acc n v _ nil -->

  fix3__f acc n v.

[ acc, n, v]

  fix2__f acc n v _ (cons _ _ _) -->

  fix3__f acc n v.

[ ]

  fix3__f -->

  acc : Coq.Term Coq.set nat =>
  n : Coq.Term Coq.set nat =>
  v : Coq.Term Coq.set (vect n) =>
  match____vect Coq.set
    (n0 : Coq.Term Coq.set nat => v0 : Coq.Term Coq.set (vect n0) => nat) acc
    (n_27_ : Coq.Term Coq.set nat =>
     e : Coq.Term Coq.set nat =>
     v_27_ : Coq.Term Coq.set (vect n_27_) =>
     fix1__g (plus acc e) n_27_ v_27_)
    n v.

[ acc, n, v]

  fix1__g acc n v -->

  fix2__g acc n v n v.

[ acc, n, v]

  fix2__g acc n v _ nil -->

  fix3__g acc n v.

[ acc, n, v]

  fix2__g acc n v _ (cons _ _ _) -->

  fix3__g acc n v.

[ ]

  fix3__g -->

  acc : Coq.Term Coq.set nat =>
  n : Coq.Term Coq.set nat =>
  v : Coq.Term Coq.set (vect n) =>
  match____vect Coq.set
    (n0 : Coq.Term Coq.set nat => v0 : Coq.Term Coq.set (vect n0) => nat) acc
    (n_27_ : Coq.Term Coq.set nat =>
     e : Coq.Term Coq.set nat =>
     v_27_ : Coq.Term Coq.set (vect n_27_) =>
     fix1__f (times acc e) n_27_ v_27_)
    n v.

def f :

  acc : Coq.Term Coq.set nat ->
  n : Coq.Term Coq.set nat ->
  v : Coq.Term Coq.set (vect n) ->
  Coq.Term Coq.set nat :=

  fix1__f.

def g :

  acc : Coq.Term Coq.set nat ->
  n : Coq.Term Coq.set nat ->
  v : Coq.Term Coq.set (vect n) ->
  Coq.Term Coq.set nat :=

  fix1__g.
;)

(; End of translation. ;)
