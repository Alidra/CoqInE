(;-----------------------------------------------------------------;)
(;-----------------  FIXPOINTS DEFINITION SCHEME  -----------------;)
(;-----------------------------------------------------------------;)

(; Required rule ;)
[s] Rule s s s --> true.

(; Natural numbers ;)
N : Type.
0 : N.
_S : N -> N.

def 1 := _S 0.
def 2 := _S 1.
def 3 := _S 2.
def 4 := _S 3.
def 5 := _S 4.


(;-----------------  Arity  -----------------;)

(; SAc k s A   represents both
   - the arity of a single body in a mutually recursive block
     without the recursive call parameters.
   - the index of expected structurally decreasing inductive argument in arity ;)

SingleArity : Sort -> Type.
SAc : N -> s : Sort -> Univ s -> SingleArity s.

def make_SA := SAc.


(;-----------------  Fetch type from Arity  -----------------;)

def SA_arity : s : Sort -> SingleArity s -> Univ s.
[s,A] SA_arity s (SAc _ _ A) --> A.



(;-----------------  Arity Lists  -----------------;)

(; This is a sized list of single arities ;)

MutualArity : Sort -> N -> Type.
MAnil  : s : Sort -> MutualArity s 0.
MAcons : s : Sort -> n : N -> SingleArity s -> MutualArity s n -> MutualArity s (_S n).

(;-----------------  Short constructor: make_MA  -----------------;)

def MutualArity' : Sort -> N -> N -> Type.
[s,n  ] MutualArity' s n 0     --> MutualArity s n.
[s,n,i] MutualArity' s n (_S i) --> SingleArity s -> MutualArity' s n i.

def MAcons_aux :
  s : Sort ->
  n : N -> m : N ->
  SingleArity s ->
  MutualArity' s n m ->     (;  SA -> ...(m)... -> SA -> MAn    ;)
  MutualArity' s (_S n) m.  (;  SA -> ...(m)... -> SA -> MAn+1  ;)
[s,n  ,A,MA   ] MAcons_aux s n 0     A MA    --> MAcons s n A MA.
[s,n,m,A,MA,A'] MAcons_aux s n (_S m) A MA A' --> MAcons_aux s n m A (MA A').

(; Use directly    make_MA s 3 a b c     ;)
def make_MA : s : Sort -> n : N -> MutualArity' s n n.
[s     ] make_MA s 0        --> MAnil s.
[s,n,SA] make_MA s (_S n) SA --> MAcons_aux s n n SA (make_MA s n).

(;-----------------  Fetch Arity from Arity List  -----------------;)

def MA_ith_SA  : s : Sort -> n : N -> MutualArity s n -> N -> SingleArity s.
[s,SA]
  MA_ith_SA s _ (MAcons _ _ SA _) 0 --> SA.
[s,n,i,MA]
  MA_ith_SA s _ (MAcons _ n _ MA) (_S i)
  -->
  MA_ith_SA s n MA i.

(;-----------------  Fetch Type from Arity List  -----------------;)

def MA_ith_arity (s : Sort) (n : N) (MA : MutualArity s n) (i : N) : Univ s :=
  SA_arity s (MA_ith_SA s n MA i).





(;------  Fetch type with recursive call arguments from Arity List  -----;)

def MA_lift_arity :
  s : Sort -> Univ s -> m : N -> MutualArity s m -> Univ s.

[s,ar] MA_lift_arity s ar _ (MAnil _) --> ar.

[s,ar,m,SA,MA]
  MA_lift_arity s ar _ (MAcons _ m SA MA)
  -->
  prod s s s I (SA_arity s SA) (f => (MA_lift_arity s ar m MA)).

def MA_arity (s : Sort) (n : N) (MA : MutualArity s n) (i : N) : Univ s
  := MA_lift_arity s (MA_ith_arity s n MA i) n MA.



(;-----------------  Fixpoint Type  -----------------;)

(; Sized list of functions of each "type with recursive calls"  ;)

(; List of MA' arity lifted with MA ;)
MutualFixpointTypeAux :
  (s : Sort) ->
  (n : N) -> MutualArity s n ->
  (i : N) -> MutualArity s i -> Type.

def MutualFixpointType (s : Sort) (n : N) (MA : MutualArity s n) : Type
  :=
  MutualFixpointTypeAux s n MA n MA.

MFTnil :
  (s : Sort) ->
  (n : N) -> (MA : MutualArity s n) ->
  MutualFixpointTypeAux s n MA 0 (MAnil s).

MFTcons :
  (s : Sort) ->
  (n : N) -> (MAn : MutualArity s n) ->
  (i : N) -> (MAi : MutualArity s i) ->
  SA : SingleArity s ->
  Term s (MA_lift_arity s (SA_arity s SA) n MAn) ->
  MutualFixpointTypeAux s n MAn i MAi ->
  MutualFixpointTypeAux s n MAn (_S i) (MAcons s i SA MAi).

(;-----------------  Short constructor: fix  -----------------;)

def MutualFixpointType' :
  (s : Sort) ->
  (n : N) -> MutualArity s n ->
  (i : N) -> MutualArity s i ->
  (j : N) -> MutualArity s j ->
  Type.

[s,n,MAn,i,MAi]
  MutualFixpointType' s n MAn i MAi _ (MAnil _)
  -->
  MutualFixpointTypeAux s n MAn i MAi.

[s,n,MAn,i,MAi,SA,j,MAj]
  MutualFixpointType' s n MAn i MAi _ (MAcons _ j SA MAj)
  -->
  Term s (MA_lift_arity s (SA_arity s SA) n MAn) ->
  MutualFixpointType' s n MAn i MAi j MAj.


def fix' :
  (s : Sort) -> (n : N) -> (MAn : MutualArity s n) ->
  (i : N) -> (MAi : MutualArity s i) ->
  (j : N) -> (MAj : MutualArity s j) ->
  SA : SingleArity s ->
  Term s (MA_lift_arity s (SA_arity s SA) n MAn) ->
  MutualFixpointType' s n MAn i      MAi                 j MAj ->
  MutualFixpointType' s n MAn (_S i) (MAcons s i SA MAi) j MAj.

[s,n,MAn,i,MAi,SA,t,MFT]
  fix' s n MAn i MAi _ (MAnil _) SA t MFT
  -->
  MFTcons s n MAn i MAi SA t MFT.

[s,n,MAn,i,MAi,j,MAj,SA,t,MFT,t']
  fix' s n MAn i MAi (_S _) (MAcons _ j _ MAj) SA t MFT t'
  -->
  fix' s n MAn i MAi j MAj SA t (MFT t').


def make_fix :
  (s : Sort) -> (n : N) -> (MAn : MutualArity s n) ->
  (i : N) -> (MAi : MutualArity s i) ->
  MutualFixpointType' s n MAn i MAi i MAi.

[s,n,MAn]
  make_fix s n MAn _ (MAnil _)
  -->
  MFTnil s n MAn.

[s,n,MAn,j,MAj,SA,t]
  make_fix s n MAn (_S _) (MAcons _ j SA MAj) t
  -->
  fix' s n MAn j MAj j MAj SA t (make_fix s n MAn j MAj).

def fix :
  s : Sort ->
  n : N ->
  MA: MutualArity s n -> MutualFixpointType' s n MA n MA n MA.

[s,n,MAn] fix s n MAn --> make_fix s n MAn n MAn.



def fix_body :
  s : Sort ->
  n : N ->
  MA: MutualArity s n ->
  MutualFixpointType s n MA ->
  i : N ->
  Term s (MA_arity s n MA i).

def fix_body' :
  s : Sort ->
  n : N -> MAn : MutualArity s n ->
  i : N -> MAi : MutualArity s i ->
  MutualFixpointTypeAux s n MAn i MAi ->
  j : N ->
  Term s (MA_lift_arity s (SA_arity s (MA_ith_SA s i MAi j)) n MAn).
[s,n,MA,MF,i] fix_body s n MA MF i --> fix_body' s n MA n MA MF i.

[s,n,MA,SA,t]
  fix_body' s n MA (_S _) (MAcons _ _ SA _) (MFTcons _ _ _ _ _ _ t _) 0
  -->
  t.

[s,n,MA,i,MAi,MFT,j]
  fix_body' s n MA (_S _) (MAcons _ i _ MAi) (MFTcons _ _ _ _ _ _ _ MFT) (_S j)
  -->
  fix_body' s n MA i MAi MFT j.



def lift (s : Sort) (s' : Sort) := cast' s s' (univ' s s) (univ' s' s').

def app_body :
  s : Sort ->
  n : N -> MA : MutualArity s n ->
  s1 : Sort ->
  s2 : Sort ->
  A : Univ s1 ->
  B : (Term s1 A -> Univ s2) ->
  body : Term s (MA_lift_arity s (prod' s1 s2 s A (x => B x)) n MA) ->
  a : Term s1 A ->
  Term s (MA_lift_arity s (lift s2 s (B a)) n MA).

[body,a]
  app_body _ _ (MAnil _) _ _ _ _ body a --> body a.

[s,n,SA,MA,s1,s2,A,B,body,a]
  app_body s _ (MAcons _ n SA MA) s1 s2 A B body a
  -->
  f => app_body s n MA s1 s2 A B (body f) a.


def fix_proj :
  s : Sort ->
  n : N -> MA: MutualArity s n ->
  MutualFixpointType s n MA ->
  i : N ->
  Term s (MA_ith_arity s n MA i).

def fix_proj_1 :
  s : Sort ->
  n : N -> MA : MutualArity s n ->
  MutualFixpointType s n MA ->
  SA : SingleArity s ->
  Term s (MA_lift_arity s (SA_arity s SA) n MA) ->
  Term s (SA_arity s SA).

[s,n,MA,MF,i]
  fix_proj s n MA MF i
  -->
  fix_proj_1 s n MA MF (MA_ith_SA s n MA i) (fix_body s n MA MF i).

[s,n,MA,MF,i,A,B,body,a,s1,s2]
  fix_proj_1 s n MA MF (SAc (_S i) _ (prod' s1 s2 _ A (x => B x))) body a
  -->
  fix_proj_1 s n MA MF
    (SAc i s (lift s2 s (B a)))
    (app_body s n MA s1 s2 A (x => B x) body a).

Guarded? : Type.
guarded : Guarded?.
def guarded? : s : Sort -> Ind : Univ s -> Term s Ind -> Guarded?.

def fix_proj_2 :
  s : Sort ->
  n : N -> MA : MutualArity s n ->
  MutualFixpointType s n MA ->
  A : Univ s ->
  Term s (MA_lift_arity s A n MA) ->
  Guarded? ->
  Term s A.

[s,n,MA,MF,Ind,B,body,a,s1]
  fix_proj_1 s n MA MF (SAc 0 _ (prod' s1 s _ Ind (x => B x))) body a
  -->
  fix_proj_2 s n MA MF
    (prod' s1 s s Ind (x => B x))
    body (guarded? s1 Ind a) a.

def fix_proj_3 :
  s : Sort ->
  n : N -> MA : MutualArity s n ->
  MutualFixpointType s n MA ->
  A : Univ s ->
  i : N -> MAi : MutualArity s i ->
  f : (k : N -> Term s (MA_ith_arity s i MAi k)) ->
  Term s (MA_lift_arity s A i MAi) ->
  Term s A.

[s,n,MA,MF,A,body]
  fix_proj_2 s n MA MF A body guarded
  -->
  fix_proj_3 s n MA MF A n MA (k => fix_proj s n MA MF k) body.

[body] fix_proj_3 _ _ _ _ _ _ (MAnil _) _ body --> body.

[s,n,MA,MF,i,MAi,A,f,body]
  fix_proj_3 s n MA MF A
    _ (MAcons _ i _ MAi)
    f
    body
  -->
  fix_proj_3 s n MA MF A
    i MAi
    (k => f (_S k))
    (body (f 0)).


def fixproj :
  s : Sort ->
  n : N ->
  MA :(MutualArity' s n n -> MutualArity s n) ->
  (
     MutualFixpointType' s n (MA (make_MA s n)) n (MA (make_MA s n)) n (MA (make_MA s n)) ->
     MutualFixpointType s n (MA (make_MA s n))
  ) ->
  i : N ->
  Term s (MA_ith_arity s n (MA (make_MA s n)) i).

[s,n,MA,MF]
  fixproj s n MA MF
  -->
  fix_proj s n
    (MA (make_MA s n))
    (MF (fix s n (MA (make_MA s n)))).



(;
Fixpoint a := a
with     b := b
with     c := c.
;)

A : Univ set.
B : Univ set.
C : Univ set.

def SA_A : SingleArity set   := make_SA 0 set A.
def SA_B : SingleArity set   := make_SA 0 set B.
def SA_C : SingleArity set   := make_SA 0 set C.
def MA   : MutualArity set 3 := make_MA set 3 SA_A SA_B SA_C.
def MFT  : MutualFixpointType set 3 MA :=
  fix set 3 MA (a => b => c => a) (a => b => c => b) (a => b => c => c).

def body_a := fix_body set 3 MA MFT 0.
def body_b := fix_body set 3 MA MFT 1.
def body_c := fix_body set 3 MA MFT 2.

def a    : Term set A := fix_proj set 3 MA MFT 0.
def b    : Term set B := fix_proj set 3 MA MFT 1.
def c    : Term set C := fix_proj set 3 MA MFT 2.

[] guarded? set A a --> guarded.
[] guarded? set B b --> guarded.
[] guarded? set C c --> guarded.





(; We ambitiously translate the following inductive definition:

Inductive nat : Type :=
| Z : nat
| S : nat -> nat.

Fixpoint plus (x:nat) (y:nat) :=
  match x with
  | Z => y
  | S x' => S (plus x' y)
  end.

Fixpoint times (x:nat) (y:nat) :=
  match x with
  | Z => Z
  | S x' => plus y (times x' y)
  end.

Inductive vect : nat -> Type :=
| nil : vect Z
| cons : forall n : nat, nat -> vect n -> vect (S n).

Fixpoint f acc n (v:vect n) {struct v} :=
  match v with
  | nil => acc
  | cons n' e v' => g (plus acc e) n' v'
  end
with g acc n v {struct v} :=
  match v with
  | nil => acc
  | cons n' e v' => f (times acc e) n' v'
  end
.

;)



(; This file was automatically generated by Coqine. ;)
(; The encoding used was: "universo". ;)

nat :
  Univ set.

def Z :
  Term set nat.

def S :
  __ : Term set nat -> Term set nat.

def _1 := S Z.
def _2 := S _1.
def _3 := S _2.
def _4 := S _3.
def _5 := S _4.
def _6 := S _5.
def _7 := S _6.
def _8 := S _7.


[] guarded? set nat Z     --> guarded.
[] guarded? set nat (S _) --> guarded.


def match____nat :
  s : Sort ->
  P : (Term set nat -> Univ s) ->
  case__Z : Term s (P Z) ->
  case__S : (__ : Term set nat -> Term s (P (S __))) ->
  x : Term set nat ->
  Term s (P x).

[ s, P, case__Z, case__S]

  match____nat s P case__Z case__S Z -->

  case__Z.

[ s, P, case__Z, case__S, __]

  match____nat s P case__Z case__S (S __) -->

  case__S __.

[ s, P, s']

  match____nat s (x => cast' _ _ (univ' s' _) _ (P x)) -->

  match____nat s' (x => P x).


P : n : Term set nat -> Univ (type z).
f0 : Term (type z) (P Z).
f1 : n : Term set nat ->
     __ : Term (type z) (P n) ->
     Term (type z) (P (S n)).


(;     f0  /  0  :  forall n:nat, P n     ;)
def nat__rect__SA : SingleArity (type z) :=
  make_SA 0 (type z) (prod set (type z) (type z) I nat (n => P n)).

(;   { f0  /  0  :  forall n:nat, P n }   ;)
def nat__rect__MA : MutualArity (type z) 1 :=
  make_MA (type z) 1 nat__rect__SA.

def nat__rect__FP : MutualFixpointType (type z) 1 nat__rect__MA :=
  fix (type z) 1 nat__rect__MA
    (nat__rect => n =>
      match____nat (type z) (n0 : Term set nat => P n0)
        f0
        (n0 : Term set nat => f1 n0 (nat__rect n0))
        n).

def nat__rect__proj := fix_proj (type z) 1 nat__rect__MA nat__rect__FP 0.


#PRINT "  nat_rect : Nat -> P n ?".
#CHECK nat__rect__proj  :  ( n : Term set nat -> Term (type z) (P n) ).


def nat__rect :
  P : (n : Term set nat -> Univ (type z)) ->
  f0 : Term (type z) (P Z) ->
  f1 : (n : Term set nat ->
       __ : Term (type z) (P n) ->
       Term (type z) (P (S n)) ) ->
  n: Term set nat ->
  Term (type z) (P n)
  :=
  P => f0 => f1 =>
  fixproj (type z) 1
    (c => c
       (make_SA 0 (type z) (prod set (type z) (type z) I nat (n => P n))))
    (c => c
      (nat__rect => n =>
        match____nat (type z) (n0 : Term set nat => P n0)
          f0
          (n0 : Term set nat => f1 n0 (nat__rect n0))
          n))
    0.


def nat__rec :

  P : (n : Term set nat -> Univ set) ->
  f0 : Term set (P Z) ->
  f1 :
    (n : Term set nat ->
     __ : Term set (P n) ->
     Term set (P (S n))) ->
  n : Term set nat ->
  Term set (P n) :=

  P : (n : Term set nat -> Univ set) =>
  nat__rect
    (cast (rule set (type z))
       (rule set (type (s z)))
       (prod set (type z) (rule set (type z))
          I nat
          (n : Term set nat =>
           univ set (type z) I))
       (prod set (type (s z))
          (rule set (type (s z))) I nat
          (n : Term set nat =>
           univ (type z) (type (s z)) I))
       I P).

def plus :
  x : Term set nat ->
  y : Term set nat ->
  Term set nat :=
  fixproj set 1
    (c=>c
      (make_SA 0 set
        (prod set set set I nat (x => prod set set set I nat (y => nat)))))
    (c=>c
      (plus => x => y =>
         match____nat set (x0 : Term set nat => nat) y
           (x' : Term set nat => S (plus x' y)) x))
    0.

#PRINT "  2+3 = 5 ?".
#CHECK plus _2 _3 == _5.



def times :
  x : Term set nat ->
  y : Term set nat ->
  Term set nat :=
  fixproj set 1
    (c=>c
      (make_SA 0 set
        (prod set set set I nat (x => prod set set set I nat (y => nat)))))
    (c=>c
      (times => x => y =>
         match____nat set (x0 : Term set nat => nat) Z
           (x' : Term set nat => plus y (times x' y)) x))
    0.


#PRINT "  2*3 = 6 ?".
#CHECK times _2 _3 == _6.

def _10    := plus _5 _5.
def _100   := times _10 _10.
def _1000  := times _10 _100.
def _10000 := times _10 _1000.

#PRINT "  100*10=10*100 ?".
#CHECK times _100 _10 == times _10 _100.

#PRINT "  100*100=10*1000 ?".
#CHECK times _100 _100 == times _10 _1000.


vect :
  __ : Term set nat -> Univ set.

def nil :
  Term set (vect Z).

def cons :
  n : Term set nat ->
  __ : Term set nat ->
  _0 : Term set (vect n) ->
  Term set (vect (S n)).

[] guarded? set (vect _) nil          --> guarded.
[] guarded? set (vect _) (cons _ _ _) --> guarded.

def match____vect :
  s : Sort ->
  P : (__ : Term set nat -> Term set (vect __) -> Univ s) ->
  case__nil : Term s (P Z nil) ->
  case__cons :
    (n : Term set nat ->
     __ : Term set nat ->
     _0 : Term set (vect n) ->
     Term s (P (S n) (cons n __ _0))) ->
  __ : Term set nat ->
  x : Term set (vect __) ->
  Term s (P __ x).

[ s, P, case__nil, case__cons]

  match____vect s P case__nil case__cons {Z} nil -->

  case__nil.

[ s, P, case__nil, case__cons, n, __, _0]

  match____vect s P case__nil case__cons {S n} (cons n __ _0) -->

  case__cons n __ _0.

[ s, P, s']

  match____vect s (__ => x => cast' _ _ (univ' s' _) _ (P __ x)) -->

  match____vect s' (__ => x => P __ x).




def vect__rect :

  P :
    (n : Term set nat ->
     v : Term set (vect n) ->
     Univ (type z)) ->
  f0 : Term (type z) (P Z nil) ->
  f1 :
    (n : Term set nat ->
     n0 : Term set nat ->
     v : Term set (vect n) ->
     __ : Term (type z) (P n v) ->
     Term (type z) (P (S n) (cons n n0 v))) ->
  n : Term set nat ->
  v : Term set (vect n) ->
  Term (type z) (P n v) :=

  P :
    (n : Term set nat ->
     v : Term set (vect n) ->
     Univ (type z)) =>
  f0 : Term (type z) (P Z nil) =>
  f1 :
    (n : Term set nat ->
     n0 : Term set nat ->
     v : Term set (vect n) ->
     __ : Term (type z) (P n v) ->
     Term (type z) (P (S n) (cons n n0 v))) =>

  fixproj (type z) 1
    (c=>c
      (make_SA 0 (type z)
        (prod set (type z) (type z) I nat
          (n => prod set (type z) (type z) I (vect n) (v => P n v)))))
    (c=>c
      (vect__rect => n => v =>
        match____vect (type z)
          (n0 : Term set nat => v0 : Term set (vect n0) => P n0 v0)
          f0
          (n0 : Term set nat =>
           n1 : Term set nat =>
           v0 : Term set (vect n0) =>
           f1 n0 n1 v0 (vect__rect n0 v0))
          n v))
      0.


def vect__rec :

  P :
    (n : Term set nat ->
     v : Term set (vect n) ->
     Univ set) ->
  f0 : Term set (P Z nil) ->
  f1 :
    (n : Term set nat ->
     n0 : Term set nat ->
     v : Term set (vect n) ->
     __ : Term set (P n v) ->
     Term set (P (S n) (cons n n0 v))) ->
  n : Term set nat ->
  v : Term set (vect n) ->
  Term set (P n v) :=

  P :
    (n : Term set nat ->
     v : Term set (vect n) ->
     Univ set) =>
  vect__rect
    (cast (rule set (rule set (type z)))
       (rule set (rule set (type (s z))))
       (prod set (rule set (type z))
          (rule set (rule set (type z))) I nat
          (n : Term set nat =>
           prod set (type z)
             (rule set (type z)) I (vect n)
             (v : Term set (vect n) =>
              univ set (type z) I)))
       (prod set (rule set (type (s z)))
          (rule set (rule set (type (s z))))
          I nat
          (n : Term set nat =>
           prod set (type (s z))
             (rule set (type (s z))) I (vect n)
             (v : Term set (vect n) =>
              univ (type z) (type (s z)) I)))
       I P).


def f_Arity := make_SA 2 set
  ( prod set set set I nat      (acc =>
    prod set set set I nat      (n =>
    prod set set set I (vect n) (v => nat)))).

def g_Arity := make_SA 2 set
  ( prod set set set I nat      (acc =>
    prod set set set I nat      (n =>
    prod set set set I (vect n) (v => nat)))).

def fg_MA := make_MA set 2 f_Arity g_Arity.

def fg_FP :=
  fix set 2 fg_MA
    (f => g => acc => n => v =>
       match____vect set
         (n0 : Term set nat => v0 : Term set (vect n0) => nat) acc
         (n_27_ : Term set nat =>
         e : Term set nat =>
         v_27_ : Term set (vect n_27_) =>
         g (plus acc e) n_27_ v_27_)
         n v
    )
    (f => g => acc => n => v =>
       match____vect set
         (n0 : Term set nat => v0 : Term set (vect n0) => nat) acc
         (n_27_ : Term set nat =>
         e : Term set nat =>
         v_27_ : Term set (vect n_27_) =>
         f (times acc e) n_27_ v_27_)
         n v
    ).

def f := fix_proj set 2 fg_MA fg_FP 0.
def g := fix_proj set 2 fg_MA fg_FP 1.

(;
  f acc n [a,b,c,d] = ((acc+a)*b + c)*d
  f acc n [a,b,c,d] =  (acc*a +b)*c + d
;)

(;   f 0 3 [3,2,1] = 7   ;)
#PRINT "  f 0 3 [3,2,1] = 7 ?".
#CHECK
  f Z _3
    (cons _2 _3 (cons _1 _2 (cons Z _1 nil)))
  ==
  plus _3 _4.

#PRINT "  f acc (n+1) (cons n a l) = g (acc+a) n l".
#CHECK
(
  acc:Term set nat =>
  n : Term set nat =>
  a : Term set nat =>
  l : Term set (vect n) =>
    f acc (S n) (cons n a l)
) == (
  acc:Term set nat =>
  n : Term set nat =>
  a : Term set nat =>
  l : Term set (vect n) =>
    g (plus acc a) n l
).
