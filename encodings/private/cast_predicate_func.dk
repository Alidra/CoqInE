(;-----------------------------------------------------------------;)
(;----------------------  PUBLIC DEFINITIONS  ---------------------;)
(;-----------------------------------------------------------------;)


(;---------------------------  Sorts  -----------------------------;)

Sort : Type.
sinf : Sort.

(;----------------------  CTS Sorts definition  -------------------;)

Nat : Type.
z : Nat.
s : Nat -> Nat.
prop : Sort.
type : Nat -> Sort.

def max : Nat -> Nat -> Nat.
[i  ] max i z --> i
[  j] max z j --> j
[i,j] max (s i) (s j) --> s (s (max i j)).


(;---------------------  Types and terms  -------------------------;)

(; Type for encoded type codes ;)
Univ : s : Sort -> Type.

(; Type decoding function ;)
def Term : s : Sort -> a : Univ s -> Type.


(;---------------------------  Predicates  ------------------------;)

Bool : Type.
eps : Bool -> Type.
true : Bool.
def forall : s : Sort -> a : Univ s -> (Term s a -> Bool) -> Bool.
[] forall _ _ (x => true) --> true.
I : eps true.


(;---------------------  CTS Axiom definition  --------------------;)

def axiom : Sort -> Sort.
[ ] axiom prop     --> type z
[i] axiom (type i) --> type (s i).

(;-----------------------  CTS Rule definition  -------------------;)

def rule : Sort -> Sort -> Sort.
[i] rule i prop --> prop.
[j] rule prop j --> j.
[i,j] rule (type i) (type j) --> type (max i j).

(;-------------------  CTS Cumulativity definition  ---------------;)

def Cumul : Sort -> Sort -> Bool.
[]    Cumul prop         _            --> true
[]    Cumul (type z)     (type _)     --> true
[i,j] Cumul (type (s i)) (type (s j)) -->
      Cumul (type i)     (type j).


(;--------------------  Term public constructors  -----------------;)

def univ : s : Sort -> Univ (axiom s).

def prod : s1 : Sort -> s2 : Sort ->
           a : Univ s1 -> b : (Term s1 a -> Univ s2) -> Univ (rule s1 s2).

def SubType : s : Sort -> s' : Sort -> Univ s -> Univ s' -> Bool.

def cast : s : Sort -> s' : Sort ->
           a : Univ s -> b  : Univ s' ->
           p : eps (SubType s s' a b) ->
           Term s a -> Term s' b.


(;-----------------------------------------------------------------;)
(;---------------------  PRIVATE DEFINITIONS  ---------------------;)
(;-----------------------------------------------------------------;)

(;----------------------------  Axiom  ----------------------------;)

[s] Term _ (univ s) --> Univ s.

(;----------------------------  Rule  -----------------------------;)

[s1, s2, a, b] Term _ (prod s1 s2 a b) --> x : Term s1 a -> Term s2 (b x).

(;-------------------------  Subtyping ----------------------------;)

[s1, s2] SubType _ _ (univ s1)        (univ s2)        --> Cumul s1 s2
[s1,s2,s2',a,b,b']
         SubType _ _ (prod s1 s2 a b) (prod s1 s2' a b') -->
         forall s1 a (x => SubType s2 s2' (b x) (b' x)).
[a]      SubType _ _ a a --> true.

(;---------------------------  Casts  -----------------------------;)

def cast' : s : Sort -> s' : Sort ->
            a : Univ s -> b : Univ s' ->
            Term s a -> Term s' b.

[s, a] Term _ (cast' _ _ (univ s) _ a) --> Term s a.

[s1,s2,a,b,t] cast s1 s2 a b _ t --> cast' s1 s2 a b t.

(;---------------------  Canonicity rules -------------------------;)

[A,t] cast' _ _ A A t --> t.

[s, s', a, c, t]
  cast' _ s' _ c (cast' s _ a _ t) -->
  cast' s s' a c t.

[s1,s1',s2,a, b]
  prod s1 s2 (cast' _ _ (univ s1') _ a) b -->
  cast'
    (axiom (rule s1' s2)) (axiom (rule s1 s2))
    (univ  (rule s1' s2)) (univ  (rule s1 s2))
	(prod s1' s2 a b).

[s1,s2,s2',a,b]
  prod s1 s2 a (x => cast' _ _ (univ s2') _ (b x)) -->
  cast'
    (axiom (rule s1 s2')) (axiom (rule s1 s2))
    (univ  (rule s1 s2')) (univ  (rule s1 s2))
    (prod s1 s2' a (x => b x)).

(; This version encodes both contravariant and covariant product subtyping. ;)
[s1,s1',s2,s3,A,A',B,C,b]
  cast' _ _ (prod s1 s2 A B) (prod s1' s3 A' C) (x => b x) -->
  x : Term s1' A' => cast' s2 s3 (B (cast' s1' s1 A' A x)) (C x) (b (cast' s1' s1 A' A x)).


(; This version encodes only covariant product subtyping.
[s1,s2,s3,A,B,C,b]
  cast' _ _ (prod' s1 s2 _ A B) (prod' _ s3 _ A C) (x => b x) -->
  x : Term s1 A => cast' s2 s3 (B x) (C x) (b x).
;)
[s1,s1',s2,s3,A,A',B,C,b,a]
  cast' _ _ (prod s1 s2 A B) (prod s1' s3 A' C) b a -->
  cast' s2 s3 (B (cast' s1' s1 A' A a)) (C a) (b (cast' s1' s1 A' A a)).

[s1,s2,A,B,a] cast' _ s2 (cast' _ _ (univ s1) _ A) B a --> cast' s1 s2 A B a.

[s1,s2,A,B,a] cast' s1 _ A (cast' _ _ (univ s2) _ B) a --> cast' s1 s2 A B a.
