(; System for CiC inspired from Assaf.
New features for this system include:
  - new [Cumul] type constructor
  - no reduction of [Cumul] to [True] anymore
  - new constructors of [Cumul]
  - no [max] operator anymore
  - associated canonicity rules removed

The canonicity rules required to
- build an inhabitant of [Cumul s1 s3] from [Cumul s1 s2] and [Cumul s2 s3]
- build an inhabitant of [Cumul (rule s1 s2) (rule s3 s2)] from [Cumul s1 s3]
- build an inhabitant of [Cumul (rule s1 s2) (rule s1 s3)] from [Cumul s2 s3]
which was not possible because it would not reduce to [I].

The solution chosen here is to have constructors to build inhabitants of the
required predicates from inhabitants of premises.
Because [Cumul] doesn't reduce anymore we also need extra constructors to
build elements of the "base" [Cumul] predicates (those that previously reduced
to [True]).

Note: this not-as-shallow encoding seem to allow for "manual" universe polymorphism.
Meaning that "abstract" lifting operations have to be proven legal at translation time.
--> See 1a_private_lift.dk
Fewer rewrite rules are necessary since calculations are instead done by the translator.
Dedukti is "discharged of calculations" through simply checking their correctness.
For a system going even further in that direction removing all rewrite rules on
predicate types:
--> see 2b_predicate.dk
;)


(;-----------------------  Natural numbers  -----------------------;)

Nat : Type.
z : Nat.
s : Nat -> Nat.

def m : Nat -> Nat -> Nat.
[i]    m i     z     --> i.
[j]    m z     j     --> j.
[i, j] m (s i) (s j) --> s (m i j).


(;---------------------------  Sorts  -----------------------------;)

Sort : Type.
prop : Sort.
type : Nat -> Sort.

(; Universe successors ;)
def succ : Sort -> Sort.
[]  succ prop     --> type z.
[i] succ (type i) --> type (s i).

(; Universe product rules ;)
def rule : Sort -> Sort -> Sort.
[s]    rule s        prop     --> prop.
[s]    rule prop     s        --> s.
[i, j] rule (type i) (type j) --> type (m i j).


(;-------------------------  Predicates  --------------------------;)

Cumul : Sort -> Sort -> Type.

cumul_prop : s : Sort -> Cumul prop s.

cumul_type_z :
  i : Nat ->
  Cumul (type z) (type i).

cumul_s :
  i : Nat -> j : Nat ->
  Cumul (type i) (type j) ->
  Cumul (type (s i)) (type (s j)).

cumul_trans :
  s1 : Sort -> s2 : Sort -> s3 : Sort ->
  Cumul s1 s2 ->
  Cumul s2 s3 ->
  Cumul s1 s3.

cumul_rule_1 :
  s1 : Sort -> s2 : Sort -> s3 : Sort ->
  Cumul s1 s3 ->
  Cumul (rule s1 s2) (rule s3 s2).

cumul_rule_2 :
  s1 : Sort -> s2 : Sort -> s3 : Sort ->
  Cumul s2 s3 ->
  Cumul (rule s1 s2) (rule s1 s3).

(; The following "refl" constructor is actually not required by the encoding.
It would allow to 0-lift a term which seems acceptable but not necessarily useful. ;)
cumul_refl : s : Sort -> Cumul s s.


(;---------------------  Types and terms  -------------------------;)

Univ : s : Sort -> Type.
def Term : s : Sort -> a : Univ s -> Type.

univ : s : Sort -> Univ (succ s).

def lift : s1 : Sort -> s2 : Sort -> Cumul s1 s2 -> Univ s1 -> Univ s2.
def prod : s1 : Sort -> s2 : Sort -> a : Univ s1 -> b : (Term s1 a -> Univ s2) -> Univ (rule s1 s2).

[s] Term _ (univ s) --> Univ s.
[s1, s2, a] Term _ (lift s1 s2 _ a) --> Term s1 a.
[s1, s2, a, b]
  Term _ (prod s1 s2 a b) --> x : Term s1 a -> Term s2 (b x).


(;---------------------  Canonicity rules -------------------------;)

[s, a] lift s s _ a --> a.

[s1, s2, s3, 1c2, 2c3, a]
  lift _ s3 2c3 (lift s1 s2 1c2 a) -->
  lift s1 s3 (cumul_trans s1 s2 s3 1c2 2c3) a.

[s1, s2, s3, 1c3, a, b]
  prod _ s2 (lift s1 s3 1c3 a) b -->
  lift (rule s1 s2) (rule s3 s2) (cumul_rule_1 s1 s2 s3 1c3) (prod s1 s2 a b).

[s1, s2, s3, 2c3, a, b]
  prod s1 _ a (x => lift s2 s3 2c3 (b x)) -->
  lift (rule s1 s2) (rule s1 s3) (cumul_rule_2 s1 s2 s3 2c3) (prod s1 s2 a (x => b x)).
